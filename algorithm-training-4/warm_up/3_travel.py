# Мэрия Москвы основательно подготовилась к празднованию тысячелетия города в 2147 году,
# построив под столицей бесконечную асфальтированную площадку, чтобы заменить все существующие в городе автомобильные дороги.
# В память о кольцевых и радиальных дорогах разрешили двигаться по площадке только двумя способами:
#
# В сторону точки начала координат или от неё. При этом из точки начала координат разрешено двигаться в любом направлении.
# Вдоль окружности с центром в начале координат и радиусом, который равен текущему расстоянию до начала координат.
# Двигаться вдоль такой окружности разрешается в любом направлении (по или против часовой стрелки).
# Вам, как ведущему программисту ответственной инстанции поручено разработать модуль, который будет определять кратчайший путь из точки A,
# с координатами (xA, yA) в точку B с координатами (xB, yB). Считайте, что менять направление движения можно произвольное количество раз,
# но оно должно всегда соответствовать одному из двух описанных выше вариантов.
#
# Формат ввода
# В первой строке ввода заданы четыре целых числа xA, yA, xB и yB, по модулю не превосходящие 106.
#
# Формат вывода
# Выведите одно число — минимальное расстояние, которое придётся преодолеть по пути из точки A в точку B,
# если не нарушать правил дорожного движения. Ваш ответ будет принят, если его абсолютная или относительная погрешность не превосходит 10-6.

import math

def TestCase():
    x_a, y_a, x_b, y_b = map(int, input().split())
    r1 = math.sqrt(x_a * x_a + y_a * y_a)
    r2 = math.sqrt(x_b * x_b + y_b * y_b)
    if r1 > r2:
        r1, r2 = r2, r1
        x_a, x_b = x_b, x_a
        y_a, y_b = y_b, y_a
    new_x = x_b * r1 / r2
    new_y = y_b * r1 / r2
    angle = abs(math.atan2(x_a * new_y - y_a * new_x, x_a * new_x + y_a * new_y))
    print(min(r1 + r2, angle * r1 + math.sqrt((new_x - x_b) * (new_x - x_b) + (new_y - y_b) * (new_y - y_b))))

t = 1
while t > 0:
    TestCase()
    t -= 1


